package com.nuwarobotics.sdk.sample.tutorial

import android.Manifest
import androidx.appcompat.app.AppCompatActivity
import android.content.pm.PackageManager
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.content.ContextCompat
import com.nuwarobotics.service.IClientId
import com.nuwarobotics.service.agent.BnfData
import com.nuwarobotics.service.agent.NuwaRobotAPI
import com.nuwarobotics.service.agent.RobotEventListener
import com.nuwarobotics.service.agent.VoiceEventListener
import com.nuwarobotics.service.agent.VoiceEventListener.ListenType
import com.nuwarobotics.service.agent.VoiceEventListener.ResultType
import com.nuwarobotics.sdk.sample.tutorial.databinding.ActivityMainBinding

import androidx.lifecycle.lifecycleScope
import io.livekit.android.AudioOptions


import io.livekit.android.LiveKit
import io.livekit.android.LiveKitOverrides
import io.livekit.android.events.RoomEvent
import io.livekit.android.events.collect
import io.livekit.android.room.Room
import io.livekit.android.room.track.LocalVideoTrack
import io.livekit.android.room.track.Track
import io.livekit.android.room.track.VideoTrack
import io.livekit.android.room.track.AudioTrack
import io.livekit.android.room.track.LocalAudioTrack

import kotlinx.coroutines.launch

class MainActivity : AppCompatActivity(), View.OnClickListener {

    companion object {
        private const val TAG = "anywhere_door"
    }

    override fun onClick(v: View) {
        // Handle click events here
    }

    private lateinit var binding: ActivityMainBinding
    lateinit var room: Room
    private lateinit var mRobot: NuwaRobotAPI
    private lateinit var mToast: Toast

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        mToast = Toast.makeText(this, "", Toast.LENGTH_SHORT)

        // init Nuwa Robot SDK with client_id and app_id which are generated by NUWA develop platform
        mRobot = NuwaRobotAPI(this, IClientId(packageName))

        // register Nuwa Robot Listener
        registerNuwaRobotListener()

        // Create Room object.
        room = LiveKit.create(applicationContext,
            overrides = LiveKitOverrides(
                audioOptions = AudioOptions(
                    javaAudioDeviceModuleCustomizer = { builder ->
                        builder.setUseStereoInput(true)
                    }
                )
            )
        )

        // Setup the video renderer
        room.initVideoRenderer(binding.renderer)
        room.initVideoRenderer(binding.localCamera)

        requestNeededPermissions { connectToRoom() }

    }

    private fun showToast(message: String) {
        mToast.setText(message)
        mToast.show()
    }

    private fun registerNuwaRobotListener() {
        mRobot.registerRobotEventListener(object : RobotEventListener {
            override fun onWikiServiceStart() {
                Log.d(TAG, "onWikiServiceStart")
                showToast("onWikiServiceStart:")
                mRobot.startTTS("機器人準備好了")
                mRobot.hideWindow(false)

                mRobot.motionReset()
            }

            override fun onWikiServiceStop() {
                Log.d(TAG, "onWikiServiceStop")
            }

            override fun onWikiServiceCrash() {
                Log.d(TAG, "onWikiServiceCrash")
            }

            override fun onWikiServiceRecovery() {
                Log.d(TAG, "onWikiServiceRecovery")
            }

            override fun onStartOfMotionPlay(motion: String) {
                Log.d(TAG, "onStartOfMotionPlay:$motion")
                showToast("onStartOfMotionPlay:$motion")
            }

            override fun onPauseOfMotionPlay(motion: String) {
                Log.d(TAG, "onPauseOfMotionPlay:$motion")
            }

            override fun onStopOfMotionPlay(motion: String) {
                Log.d(TAG, "onStopOfMotionPlay:$motion")
                showToast("onStopOfMotionPlay:$motion")
            }

            override fun onCompleteOfMotionPlay(motion: String) {
                Log.d(TAG, "onCompleteOfMotionPlay:$motion")
                showToast("onCompleteOfMotionPlay:$motion")
                mRobot.hideWindow(false)
            }

            override fun onPlayBackOfMotionPlay(motion: String) {
                Log.d(TAG, "onPlayBackOfMotionPlay:$motion")
            }

            override fun onErrorOfMotionPlay(errorcode: Int) {
                Log.d(TAG, "onErrorOfMotionPlay:$errorcode")
                mRobot.hideWindow(false)
            }

            override fun onPrepareMotion(b: Boolean, s: String, v: Float) {
            }

            override fun onCameraOfMotionPlay(motion: String) {
                Log.d(TAG, "onCameraOfMotionPlay:$motion")
            }

            override fun onGetCameraPose(
                x: Float, y: Float, z: Float,
                Xx: Float, Yx: Float, Zx: Float,
                Xy: Float, Yy: Float, Zy: Float,
                Xz: Float, Yz: Float, Zz: Float
            ) {
            }

            override fun onTouchEvent(type: Int, touch: Int) {
                Log.d(TAG, "onTouchEvent:$type, touch:$touch")
            }

            override fun onPIREvent(value: Int) {
                Log.d(TAG, "onPIREvent:$value")
            }

            override fun onTap(body: Int) {
                Log.d(TAG, "onTap:$body")
            }

            override fun onLongPress(body: Int) {
                Log.d(TAG, "onLongPress:$body")
            }

            override fun onWindowSurfaceReady() {
                Log.d(TAG, "onWindowSurfaceReady")
            }

            override fun onWindowSurfaceDestroy() {
                Log.d(TAG, "onWindowSurfaceDestroy")
            }

            override fun onTouchEyes(eyeLR: Int, type: Int) {
                Log.d(TAG, "onTouchEyes:$eyeLR, type:$type")
            }

            override fun onRawTouch(i: Int, i1: Int, i2: Int) {
            }

            override fun onFaceSpeaker(direction: Float) {
                Log.d(TAG, "onFaceSpeaker:$direction")
            }

            override fun onActionEvent(i: Int, i1: Int) {
            }

            override fun onDropSensorEvent(i: Int) {
                Log.d(TAG, "onDropSensorEvent:$i")
            }

            override fun onMotorErrorEvent(i: Int, i1: Int) {
                Log.d(TAG, "onMotorErrorEvent:$i")
            }
        })

        mRobot.registerVoiceEventListener(object : VoiceEventListener {
            override fun onWakeup(isError: Boolean, score: String, direction: Float) {
                Log.d(TAG, "onWakeup:${!isError}, score:$score")
                showToast("onWakeup:${!isError}, score:$score")
            }

            override fun onTTSComplete(isError: Boolean) {
                Log.d(TAG, "onTTSComplete${!isError}")
                showToast("onTTSComplete:${!isError}")
            }

            override fun onSpeechRecognizeComplete(isError: Boolean, iFlyResult: ResultType, json: String) {
                Log.d(TAG, "onSpeechRecognizeComplete:${!isError}, json:$json")
                showToast("雲端結果：$json")
            }

            override fun onSpeech2TextComplete(isError: Boolean, json: String) {
                Log.d(TAG, "onSpeech2TextComplete:${!isError}, json:$json")
                showToast("語音轉文字(語音輸入法)：$json")
            }

            override fun onSpeechState(type: ListenType, state: VoiceEventListener.SpeechState) {
                Log.d(TAG, "onSpeechState:$type, state:$state")
            }

            override fun onMixUnderstandComplete(isError: Boolean, iFlyResult: ResultType, json: String) {
                Log.d(TAG, "onMixUnderstandComplete:${!isError}, json:$json")
                if (!isError) {
                    if (iFlyResult == ResultType.LOCAL_COMMAND) {
                        showToast("local ASR:$json")
                    } else {
                        showToast("cloud ASR:$json")
                    }
                } else {
                    mRobot.startTTS("網路或訊飛不夠力")
                    showToast("網路或訊飛不夠力 $json")
                }
            }

            override fun onGrammarState(isError: Boolean, info: String) {
                Log.d(TAG, "onGrammarState:${!isError}, info:$info")
               
            }

            override fun onListenVolumeChanged(listenType: ListenType, volume: Int) {
            }

            override fun onSpeakState(type: VoiceEventListener.SpeakType, state: VoiceEventListener.SpeakState) {
                Log.d(TAG, "onSpeakState:$type, state:$state")
            }
        })
    }

    private fun connectToRoom() {
        val url = "wss://anywhere-door-uav9tfq2.livekit.cloud"
        // val token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTEzNTk1MDIsImlzcyI6IkFQSUVqaWV5d0NXdTVYRyIsIm5hbWUiOiJrZWl0aCIsIm5iZiI6MTc1MTI3MzEwMiwic3ViIjoia2VpdGgiLCJ2aWRlbyI6eyJyb29tIjoiYWxwaGEiLCJyb29tSm9pbiI6dHJ1ZX19.HptTr_1WYhqAcwUGwhbVcq1ZDaTwHunuyoACXGAWQXw"
        val token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NTIwNDA0NTMsImlzcyI6IkFQSUVqaWV5d0NXdTVYRyIsIm5hbWUiOiJrZWl0aCIsIm5iZiI6MTc1MTQzNTY1Mywic3ViIjoia2VpdGgiLCJ2aWRlbyI6eyJyb29tIjoiYWxwaGEiLCJyb29tSm9pbiI6dHJ1ZX19.yu_6Iacfa4J-puQLMmnt1QqOqgnkLwOG7txxA8UDjHg"
        Log.d(TAG, "connectToRoom: $url")

        lifecycleScope.launch {
            // Setup event handling.
            launch {
                room.events.collect { event ->
                    when (event) {
                        is RoomEvent.TrackSubscribed -> onTrackSubscribed(event)
                        else -> {}
                    }
                }
            }

            // Connect to server.
            try {
                room.connect(
                    url,
                    token
                )
            } catch (e: Exception) {
                Log.e(TAG, "Error while connecting to server:", e)
                return@launch
            }

            // Turn on audio/video recording.
            val localParticipant = room.localParticipant
            val micRet = localParticipant.setMicrophoneEnabled(true)
            Log.d(TAG, "setMicrophoneEnabled result: $micRet")
            val cameraRet = localParticipant.setCameraEnabled(true)
            Log.d(TAG, "setCameraEnabled result: $cameraRet")

            // Attach local video camera
            val localTrack = localParticipant.getTrackPublication(Track.Source.CAMERA)?.track as? LocalVideoTrack
            if (localTrack != null) {
                attachLocalVideo(localTrack)
            }

            // Attach video of remote participant if already available.
            val remoteVideoTrack = room.remoteParticipants.values.firstOrNull()
                ?.getTrackPublication(Track.Source.CAMERA)
                ?.track as? VideoTrack

            if (remoteVideoTrack != null) {
                attachVideo(remoteVideoTrack)
            }

            val audioTrack = localParticipant.getTrackPublication(Track.Source.MICROPHONE)?.track as? LocalAudioTrack
            audioTrack?.setAudioBufferCallback(object : io.livekit.android.audio.AudioBufferCallback {
                override fun onBuffer(
                    buffer: java.nio.ByteBuffer,
                    audioFormat: Int,
                    channelCount: Int,
                    sampleRate: Int,
                    bytesRead: Int,
                    captureTimeNs: Long
                ): Long {
                    val formatName = when (audioFormat) {
                        android.media.AudioFormat.ENCODING_PCM_8BIT -> "PCM_8BIT"
                        android.media.AudioFormat.ENCODING_PCM_16BIT -> "PCM_16BIT"
                        android.media.AudioFormat.ENCODING_PCM_FLOAT -> "PCM_FLOAT"
                        else -> "UNKNOWN($audioFormat)"
                    }
                    Log.d(TAG, "AudioBuffer - Format: $formatName, Channels: $channelCount, SampleRate: $sampleRate Hz, BytesRead: $bytesRead, BufferSize: ${buffer.remaining()}, CaptureTime: ${captureTimeNs}ns")
                    return captureTimeNs
                }
            })

            // register rpc
            localParticipant.registerRpcMethod(
                "up"
            ) { data ->
                println("Received greeting from ${data.callerIdentity}: ${data.payload}")
                mRobot.forwardInAccelerationEx()
                "up, ${data.callerIdentity}!"
            }

            localParticipant.registerRpcMethod(
                "down"
            ) { data ->
                println("Received greeting from ${data.callerIdentity}: ${data.payload}")
                mRobot.backInAccelerationEx()
                "down, ${data.callerIdentity}!"
            }

            localParticipant.registerRpcMethod(
                "left"
            ) { data ->
                println("Received greeting from ${data.callerIdentity}: ${data.payload}")
                mRobot.turnLeftEx()
                "left, ${data.callerIdentity}!"
            }

            localParticipant.registerRpcMethod(
                "right"
            ) { data ->
                println("Received greeting from ${data.callerIdentity}: ${data.payload}")
                mRobot.turnRightEx()
                "right, ${data.callerIdentity}!"
            }

        }
    }

    private fun onTrackSubscribed(event: RoomEvent.TrackSubscribed) {
        val track = event.track
        if (track is VideoTrack) {
            attachVideo(track)
            Log.d(TAG, "onTrackSubscribed: VideoTrack")
        }
        if (track is AudioTrack) {
            Log.d(TAG, "onTrackSubscribed: AudioTrack")
        }
    }

    private fun attachVideo(videoTrack: VideoTrack) {
        videoTrack.addRenderer(binding.renderer)
        binding.progress.visibility = View.GONE
    }

    private fun attachLocalVideo(videoTrack: VideoTrack) {
        videoTrack.addRenderer(binding.localCamera)
    }

    private fun requestNeededPermissions(onHasPermissions: () -> Unit) {
        val requestPermissionLauncher =
            registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { grants ->
                var hasDenied = false
                // Check if any permissions weren't granted.
                for (grant in grants.entries) {
                    if (!grant.value) {
                        showToast("Missing permission: ${grant.key}")
                        Log.d(TAG, "requestNeededPermissions: ${grant.key}")
                        hasDenied = true
                    }
                }

                if (!hasDenied) {
                    onHasPermissions()
                }
            }

        // Assemble the needed permissions to request
        val neededPermissions = listOf(Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA)
            .filter { ContextCompat.checkSelfPermission(this, it) == PackageManager.PERMISSION_DENIED }
            .toTypedArray()

        Log.d(TAG, "requestNeededPermissions: ${neededPermissions.joinToString(", ")}")

        if (neededPermissions.isNotEmpty()) {
            requestPermissionLauncher.launch(neededPermissions)
        } else {
            onHasPermissions()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        room.disconnect()
    }
}

